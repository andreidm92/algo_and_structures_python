"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.
"""
"""Проверка сложности"""

# первые три присваивания - это константа (3)

m = 6
SUM_E = 0
n = 0

# два присваивания, повторяющиеся n раз (2n)
for i in range (0,m):
    n += 1
    SUM_E += 1*(-0.5)**(n-1)

# последняя операция - это константа (1)
print(f'Сумма элементов этого ряда чисел - {SUM_E}')

# T(n)=3+2n+1=2n+4
# O(n) - линейная зависимость у алгоритма

'''Рекурсия'''
# одно присваивание, повторяющиеся n раз (n)
def SUM_RE (m):
    if m > 1:
        return float(SUM_RE(m-1)) + float(1*(-0.5)**(m-1))
    else:
# Последняя операция - константа (1)
        return 1
# Присваивание и операция print - это константа (2)
m = 6
print(f'Сумма элементов этого ряда чисел - {SUM_RE(m)}')

# T(n) = n+1+2 = n + 3
# O(n) - - линейная зависимость у алгоритма


"""Анализ скорости выполнения алгоритма"""

import timeit

# Измерение Цикла - непосредственно вставлен код
print(timeit.timeit("""
m = 6
SUM_E = 0
n = 0

for i in range (0,m):
    n += 1
    SUM_E += 1*(-0.5)**(n-1)

"""))

# Рекурсия
print(timeit.timeit("SUM_RE (6)", setup="from __main__ import SUM_RE", number=1000))


# Преобразован цикл в функцию

def CALC_F():
    m = 6
    SUM_E = 0
    n = 0

    for i in range (0,m):
        n += 1
        SUM_E += 1*(-0.5)**(n-1)

# print(f'Сумма элементов этого ряда чисел - {SUM_E}')

print(timeit.timeit("CALC_F ()", setup="from __main__ import CALC_F", number=1000))
''' Рекурсия проигрывает в скорости. У нее 0,015, а у цикла - 0,011. Очень долго считает цикл если его 
просто вставляют в timeit, очевидно обращение к функции ускоряет процесс.'''

import cProfile
cProfile.run('SUM_RE (m)')
''' Очень полезная функция для анализа более сложных программ, потому что дает аналитику с разбивкой. 
В данном случае мы видим нули, потому что очень маленькие значения времени. '''



